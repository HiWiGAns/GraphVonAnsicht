/*
 * This build file was auto generated by running the Gradle 'init' task
 * by 'lucas' at '6/24/16 9:44 AM' with Gradle 2.13
 *
 * This generated file contains a sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at https://docs.gradle.org/2.13/userguide/tutorial_java_projects.html
 */

// In this section you declare the dependencies for your production and test code

allprojects {
	apply plugin: 'eclipse'
	apply plugin: 'java'
    group = 'edu.kit.student.gans'
    version = '0.1.0'

	compileJava { 
	  options.encoding = "UTF-8" 
	}
    dependencies {
		compile 'org.slf4j:slf4j-api:1.7.21'

		compile group: 'ch.qos.logback', name:'logback-classic', version: '1.0.9'                                                                                                                                                                 
		compile group: 'ch.qos.logback', name:'logback-core', version: '1.0.9' 

		testCompile 'junit:junit:4.12'
    }
	repositories {
		jcenter()
	}
}
dependencies {
    compile project(":shared")
	compile project(":app")
    compile project(":plugins:sugiyama")
    compile project(":plugins:joana")
    compile project(":plugins:svg")
    compile project(":plugins:graphml")
}

subprojects.each { subproject -> evaluationDependsOn(subproject.path)}

private def mergeFiles(targetDir, fileTrees, relativePath) {
  // prepare the merge
  def mergedFile = new File("${targetDir}/${relativePath}")
  new File(mergedFile.parent).mkdirs()
 
  fileTrees*.matching({ include "**/${relativePath}" })*.each {
    mergedFile << it.bytes << "\n"
  }
}

task allJar(type: Jar, dependsOn: classes) {
    baseName = 'graphvonansicht'
    def mergeDir = "${buildDir}/merge"
    println mergeDir

    manifest {
        attributes 'Main-Class': 'edu.kit.student.gui.GAnsMediator'
    }

    subprojects.findAll {it.name != "plugins"}.each { subproject -> 
       from subproject.configurations.archives.allArtifacts.files.collect {
          zipTree(it)
       }
    }
    // might need a lazy var in a multi-module project where deps are inherited
    def runtimeDeps = configurations.runtime.collect { zipTree(it) }
    def myServiceConfig = 'META-INF/services/edu.kit.student.plugin.Plugin'
    
    doFirst {
        new File(mergeDir).delete()
        mergeFiles(mergeDir, runtimeDeps, myServiceConfig)
    }
 
    // this project's classes and all deps
    //from sourceSets*.classesDir
    from(runtimeDeps) {
        exclude myServiceConfig
    }
    from mergeDir
}

eclipse {
    classpath {
        file {
            withXml {
                def node = it.asNode()
            }
            whenMerged { classpath ->
           	    def cons = classpath.getEntries().findAll { it.kind == 'con' }.findAll { it.path.contains('JRE_CONTAINER') }
           	    println cons.get(0).path
           	    
           	    cons.findAll{ it.path.contains("JRE_CONTAINER")}.collect { entry ->
           	  	  entry.accessRules.add(new org.gradle.plugins.ide.eclipse.model.AccessRule('accessible', 'javafx/**'))
           	    }
            }
        }
    }
}

task alljavadoc(type: Javadoc) {
    source subprojects.collect { it.sourceSets.main.allJava }
    classpath = files(subprojects.collect { it.sourceSets.main.compileClasspath })
    destinationDir = file("${buildDir}/docs/javadoc")
}